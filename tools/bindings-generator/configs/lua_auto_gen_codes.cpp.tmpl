\#pragma once

## include headers
\#include "scripting/lua-bindings/auto/tolua_auto_convert.h"

#for header in $headers
    #set relative = '..'
    #for search_path in $search_paths
        #set relative = os.path.relpath(header, $search_path)
        #if not '..' in relative
            #break
        #end if
    #end for
    #if not '..' in relative
\#include "${relative.replace(os.path.sep, '/')}"
    #else
\#include "${os.path.basename(header)}"
    #end if
#end for

NS_AX_BEGIN


#def parseFunctionArgs(cls, func)
    #if func.is_constructor or func.static
        #set offset = 1
    #else
        #set offset = 2
    auto self = (${cls.ns_full_name}*) Tolua::toType(L, "${cls.luaClassName}", 1);
    if (!self) {
        return 0;
    }
    #end if

    #set params = []
    #set retParams = []
    #for i in range(len(func.arguments))
        #set tp = func.arguments[i]
        #if tp.is_class and tp.is_pointer == 0
            #silent params.append('*arg%d' % i)
        #elif tp.isBasicTypePointer
            #silent params.append('&arg%d' % i)
            #silent retParams.append(('arg%d' % i , tp))
        #else
            #silent params.append('arg%d' % i)
        #end if
    ${tp.genGetCode(i + offset, 'arg%d' % i, True)}
    #end for
    #set extraparms = ', '.join(params)
    ## 
    #if func.is_constructor:
    auto ret = new ${cls.ns_full_name}(${extraparms});
    Tolua::pushType(L, (void*)ret , "${cls.luaClassName}");
    return 1;
    #else
        #if func.static:
            #if func.ret_type.retCount == 0
    ${cls.ns_full_name}::${func.name}(${extraparms});
            #else
    auto ret = ${cls.ns_full_name}::${func.name}(${extraparms});
    ${func.ret_type.genPushCode('ret', True)}
            #end if
            #set nReturns = func.ret_type.retCount + len(retParams)
            #if nReturns > 0
                #if len(retParams) > 0
                    #for arg, tp in retParams:
    ${tp.genPushCode(arg, False)}
                    #end for
                #end if
    return ${nReturns};
            #else
    return 0;
            #end if
        #else
            #if func.ret_type.retCount == 0
    self->${func.name}(${extraparms});
            #else
    auto ret = self->${func.name}(${extraparms});
    ${func.ret_type.genPushCode('ret', True)}
            #end if
            #set nReturns = func.ret_type.retCount + len(retParams)
            #if nReturns > 0
                #if len(retParams) > 0
                    #for arg, tp in retParams:
    ${tp.genPushCode(arg, False)}
                    #end for
                #end if
    return ${nReturns};
            #else
    return 0;
            #end if
        #end if
    #end if
#end def

## reister class
#for clsType in $classTypes
    #set cls = $parsedClasses[clsType]

    #if cls.hasConstructor
        ## finalize
static int ${cls.cppRefName}__finalize(lua_State* L) {
    AX_ASSERT(Tolua::isType(L, "${cls.luaClassName}", 1));
    auto obj = (${cls.ns_full_name}*)Tolua::toType(L, "${cls.luaClassName}", 1);
    delete obj;
    return 0;
}

        ## constructors
        #for name, func in cls.validConstructors.items()
static int ${cls.cppRefName}__${name}(lua_State* L) {
$parseFunctionArgs(cls, func)
}
        #end for
    #end if  ## cls.hasConstructor

    ## methods implementation
    #for m in cls.validMethods
static int ${cls.cppRefName}_${m.lua_func_name}(lua_State* L) {
$parseFunctionArgs(cls, m)
}
    #end for

    ## static methods implementation
    #for m in cls.validStaticMethods
static int ${cls.cppRefName}_${m.lua_func_name}__static(lua_State* L) {
$parseFunctionArgs(cls, m)
}
    #end for

    ## field implementation
    #for m in cls.validFields
        #if m.ntype.retCount == 1
static int ${cls.cppRefName}_${m.name}__get(lua_State* L) {
    auto self = (${cls.ns_full_name}*) Tolua::toType(L, "${cls.luaClassName}", 1);
    if (!self) {
        return 0;
    }
    ${m.ntype.genPushCode('self->%s' % m.name, True)}
    return 1;
}
        #end if

static int ${cls.cppRefName}_${m.name}__set(lua_State* L) {
    auto self = (${cls.ns_full_name}*) Tolua::toType(L, "${cls.luaClassName}", 1);
    if (!self) {
        return 0;
    }
    ${m.ntype.genGetCode(2, 'arg', True)}

    #if m.ntype.isClassNoPointer
    self->${m.name} = *arg;
    #else
    self->${m.name} = arg;
    #end if

    return 0;
}
    #end for

void register_${cls.cppRefName}(lua_State* L) {
    #set baseName = cls.parents[0].luaClassName if len($cls.parents) > 0 else ''
    #set finalizeName = cls.cppRefName + '__finalize' if cls.hasConstructor else 'nullptr'
    Tolua::declare_cclass("${cls.luaClassName}", "${baseName}", ${finalizeName});

    #if cls.hasConstructor
    Tolua::declare_member_type("constructors");
        #for name, func in cls.validConstructors.items()
    Tolua::add_member("${name}", ${cls.cppRefName}__${name});
        #end for
    Tolua::declare_end();
    #end if
## 
    #if cls.validFields
    Tolua::declare_member_type("fields");
        #for m in cls.validFields
            #if m.ntype.retCount == 1
    Tolua::add_member("${m.name}.get", ${cls.cppRefName}_${m.name}__get);
            #end if
    Tolua::add_member("${m.name}.set", ${cls.cppRefName}_${m.name}__set);
        #end for
    Tolua::declare_end();
    #end if
## 
    #if cls.methods
    Tolua::declare_member_type("methods");
        #for m in cls.validMethods
    Tolua::add_member("${m.lua_func_name}", ${cls.cppRefName}_${m.lua_func_name});
        #end for
    Tolua::declare_end();
    #end if

    #if cls.static_methods
    Tolua::declare_member_type("static_methods");
        #for m in cls.validStaticMethods
    Tolua::add_member("${m.lua_func_name}", ${cls.cppRefName}_${m.lua_func_name}__static);
        #end for
    Tolua::declare_end();
    #end if

    Tolua::declare_end();
    auto typeName = typeid(${cls.ns_full_name}).name(); // rtti is literal storage
    Tolua::luaType[reinterpret_cast<uintptr_t>(typeName)] = "${cls.luaClassName}";
}
#end for

## registerAutoCode
void Tolua::registerAutoCode()
{
    declare_ns(NULL);
    declare_ns("__tolua");

#set target_ns = None
#for clsType in $classTypes
    #set cls = $parsedClasses[clsType]
    #if target_ns != cls.luaNSName
        #if target_ns != None
    declare_end();
        #end if
        #set target_ns = cls.luaNSName

    declare_ns("${target_ns}");
    #end if
    register_${cls.cppRefName}(_state);
#end for
#if target_ns != None
    declare_end();
#end if

    declare_end();
    declare_end();
}

NS_AX_END
