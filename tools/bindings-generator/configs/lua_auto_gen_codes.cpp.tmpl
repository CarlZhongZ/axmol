\#pragma once

## include headers
\#include "scripting/lua-bindings/auto/tolua_auto_convert.h"

#for header in $code_includes
\#include "${header}"
#end for

NS_AX_BEGIN


#def parseFunctionArgs(cls, func)
    #if func.is_constructor or func.isStaticMethod
        #set offset = 1
    #else
        #set offset = 2
    ${cls.type.genGetCode(1, "self", True)}
    ##     #if cls.isClass
    ## if (!self) {
    ##     return 0;
    ## }
    ##     #end if
    #end if

    #set params = []
    #set retParams = []
    #for i in range(len(func.arguments))
        #set tp = func.arguments[i]
        #if tp.isClassNoPointer
            #silent params.append('*arg%d' % i)
        #elif tp.isBasicTypePointer
            #silent params.append('&arg%d' % i)
        #else
            #silent params.append('arg%d' % i)
        #end if

        #if tp.isRetParmType
            #silent retParams.append(('arg%d' % i , tp))
    ${tp.cppDeclareTypeName} arg${i};
        #else
    ${tp.genGetCode(i + offset, 'arg%d' % i, True)}
        #end if
    #end for
    #set extraparms = ', '.join(params)
    ## 
    #if func.is_constructor:
        #if cls.isClass:
    auto ret = new ${cls.ns_full_name}(${extraparms});
        #else:
    ${cls.ns_full_name} ret${'(' + extraparms + ')' if params else ''};
        #end if
    ${cls.type.genPushCode('ret', False)}
    return 1;
    #else
        #if func.isStaticMethod:
            #if func.ret_type.retCount == 0
    ${cls.ns_full_name}::${func.name}(${extraparms});
            #else
    auto ret = ${cls.ns_full_name}::${func.name}(${extraparms});
            #end if
        #else
            #if func.ret_type.retCount == 0
    self${'->' if cls.isClass else '.'}${func.name}(${extraparms});
            #else
    auto ret = self${'->' if cls.isClass else '.'}${func.name}(${extraparms});
            #end if
        #end if
        #if func.isStructNoneConstMethod
            #set nSelfRet = 1
    ${cls.type.genPushCode('self', False)}
        #else
            #set nSelfRet = 0
        #end if
        #if func.ret_type.retCount == 1
    ${func.ret_type.genPushCode('ret', True)}
        #end if
        #if len(retParams) > 0
            #for arg, tp in retParams:
    ${tp.genPushCode(arg, False)}
            #end for
        #end if
    return ${func.ret_type.retCount + len(retParams) + nSelfRet};
    #end if
#end def

## reister class
#for cls in $arrRegAllClassesOrStructs

    #if cls.isClassAndHasConstructor
        ## finalize
static int ${cls.cppRefName}__finalize(lua_State* L) {
    AX_ASSERT(Tolua::isType(L, "${cls.luaClassName}", 1));
    auto obj = (${cls.ns_full_name}*)Tolua::toType(L, "${cls.luaClassName}", 1);
    delete obj;
    return 0;
}
    #end if

    #if cls.hasConstructor
        ## constructors
        #for name, func in cls.validConstructors.items()
static int ${cls.cppRefName}__constructor_${name}(lua_State* L) {
$parseFunctionArgs(cls, func)
}
        #end for
    #end if

    ## methods implementation
    #for _, m in cls.validMethods.items()
static int ${cls.cppRefName}__method_${m.lua_func_name}(lua_State* L) {
$parseFunctionArgs(cls, m)
}
    #end for

    ## static methods implementation
    #for _, m in cls.validStaticMethods.items()
static int ${cls.cppRefName}__static_${m.lua_func_name}(lua_State* L) {
$parseFunctionArgs(cls, m)
}
    #end for

    #if cls.isClass
    ## field implementation
    #for m in cls.validFields
        #if m.ntype.retCount == 1
static int ${cls.cppRefName}_${m.name}__get(lua_State* L) {
    auto self = (${cls.ns_full_name}*) Tolua::toType(L, "${cls.luaClassName}", 1);
    if (!self) {
        return 0;
    }
    ${m.ntype.genPushCode('self->%s' % m.name, True)}
    return 1;
}
        #end if

static int ${cls.cppRefName}_${m.name}__set(lua_State* L) {
    auto self = (${cls.ns_full_name}*) Tolua::toType(L, "${cls.luaClassName}", 1);
    if (!self) {
        return 0;
    }
    ${m.ntype.genGetCode(2, 'arg', True)}

        #if m.ntype.isClassNoPointer
    self->${m.name} = *arg;
        #else
    self->${m.name} = arg;
        #end if

    return 0;
}
    #end for
    #end if  ## cls.isClass

void register_${cls.cppRefName}(lua_State* L) {
    #set baseName = cls.parents[0].luaClassName if len($cls.parents) > 0 else ''
    #set finalizeName = cls.cppRefName + '__finalize' if cls.isClassAndHasConstructor else 'nullptr'
    Tolua::declare_cclass("${cls.luaClassName}", "${baseName}", ${finalizeName});

    #if cls.hasConstructor
    Tolua::declare_member_type("constructors");
        #for name, func in cls.validConstructors.items()
    Tolua::add_member("${name}", ${cls.cppRefName}__constructor_${name});
        #end for
    Tolua::declare_end();
    #end if
    ## 
    #if cls.isClass and cls.validFields
    Tolua::declare_member_type("fields");
        #for m in cls.validFields
            #if m.ntype.retCount == 1
    Tolua::add_member("${m.name}.get", ${cls.cppRefName}_${m.name}__get);
            #end if
    Tolua::add_member("${m.name}.set", ${cls.cppRefName}_${m.name}__set);
        #end for
    Tolua::declare_end();
    #end if
    ## 
    #if cls.methods
    Tolua::declare_member_type("methods");
        #for _, m in cls.validMethods.items()
    Tolua::add_member("${m.lua_func_name}", ${cls.cppRefName}__method_${m.lua_func_name});
        #end for
    Tolua::declare_end();
    #end if

    #if cls.static_methods
    Tolua::declare_member_type("static_methods");
        #for _, m in cls.validStaticMethods.items()
    Tolua::add_member("${m.lua_func_name}", ${cls.cppRefName}__static_${m.lua_func_name});
        #end for
    Tolua::declare_end();
    #end if

    Tolua::declare_end();
    auto typeName = typeid(${cls.ns_full_name}).name(); // rtti is literal storage
    Tolua::luaType[reinterpret_cast<uintptr_t>(typeName)] = "${cls.luaClassName}";
}
#end for

## registerAutoCode
void Tolua::registerAutoCode()
{
    declare_ns(NULL);
    declare_ns("__tolua");

#set target_ns = None
#for cls in $arrRegAllClassesOrStructs
    #if target_ns != cls.luaNSName
        #if target_ns != None
    declare_end();
        #end if
        #set target_ns = cls.luaNSName

    declare_ns("${target_ns}");
    #end if
    register_${cls.cppRefName}(_state);
#end for

#if target_ns != None
    declare_end();
#end if

    declare_end();
    declare_end();
}

void Tolua::pushStaticCppValues(lua_State* L) {
#for cls in $arrRegAllClassesOrStructs
    #set validStaticConstVars = cls.validStaticConstVars
    #if validStaticConstVars

    lua_getfield(L, LUA_REGISTRYINDEX, "${cls.luaClassName}");
        #for name, tp in validStaticConstVars
            #set varNSName = cls.ns_full_name + '::' + name
    ${tp.genPushCode(varNSName, True)}
    lua_setfield(L, -2, "${name}");
        #end for
    lua_pop(L, 1);
    #end if
#end for
}

NS_AX_END
