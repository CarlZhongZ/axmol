\#pragma once

## include headers
\#include "scripting/lua-bindings/manual/Tolua.h"
#for header in $headers
    #set relative = '..'
    #for search_path in $search_paths
        #set relative = os.path.relpath(header, $search_path)
        #if not '..' in relative
            #break
        #end if
    #end for
    #if not '..' in relative
\#include "${relative.replace(os.path.sep, '/')}"
    #else
\#include "${os.path.basename(header)}"
    #end if
#end for

NS_AX_BEGIN

## struct convert logic implementation
#for structType in $structTypes
    #set structInfo = $parsedStructs[structType]
template<>
void Tolua::tolua_push_value(lua_State* L, const ${structInfo.ns_full_name} &value) {
    lua_newtable(L);
    #for field in structInfo.fields
    ${field.ntype.genPushCode('value.%s' % field.name)}
    lua_setfield(L, -2, "${field.name}");
    #end for
}

template<>
void Tolua::tolua_get_value(lua_State* L, int loc, ${structInfo.ns_full_name} &value) {
    if (!lua_istable(L, loc)) {
        return;
    }

    #for field in structInfo.fields
    lua_getfield(L, loc, "${field.name}");
    ${field.ntype.genGetCode(-1, 'value.%s' % field.name)}
    lua_pop(L, 1);
    #end for
}
#end for


#def parseFunctionArgs(cls, func)
    #if func.is_constructor or func.static
        #set offset = 1
    #else
        #set offset = 2
    auto self = (${cls.ns_full_name}*) Tolua::tousertype(L, "${cls.luaClassName}", 1);
    #end if
    #set params = []
    #for i in range(len(func.arguments))
        #set tp = func.arguments[i]
    ${tp.cppDeclareTypeName} arg_${i};
        #silent params.append('arg_%d' % i)
    ${tp.genGetCode(i + offset, 'arg_%d' % i)}
    #end for
    #set extraparms = ', '.join(params)

    #if func.is_constructor:
    auto ret = new ${cls.ns_full_name}(${extraparms});
    Tolua::pushusertype(L, (void*)ret , "${cls.luaClassName}");
    return 1;
    #else
        #if func.static:
            #if func.ret_type.is_void
    ${cls.ns_full_name}::${func.name}(${extraparms});
    return 0;
            #else
    auto ret = ${cls.ns_full_name}::${func.name}(${extraparms});
    ${func.ret_type.genPushCode('ret')}
    return 1;
            #end if
        #else
            #if func.ret_type.is_void
    self->${func.name}(${extraparms});
    return 0;
            #else
    auto ret = self->${func.name}(${extraparms});
    ${func.ret_type.genPushCode('ret')}
    return 1;
            #end if
        #end if
    #end if
#end def

## reister class
#for clsType in $classTypes
    #set cls = $parsedClasses[clsType]

    #if cls.hasConstructor
        ## finalize
static int ${cls.cppRefName}__finalize(lua_State* L) {
    AX_ASSERT(Tolua::isusertype(L, "${cls.luaClassName}", 1));
    auto obj = (${cls.ns_full_name}*)Tolua::tousertype(L, "${cls.luaClassName}", 1);
    delete obj;
    return 0;
}

        ## constructors
        #for name, func in cls.validConstructors.items()
static int ${cls.cppRefName}__${name}(lua_State* L) {
$parseFunctionArgs(cls, func)
}
        #end for
    #end if  ## cls.hasConstructor

    ## methods implementation
    #for m in cls.validMethods
static int ${cls.cppRefName}_${m.lua_func_name}(lua_State* L) {
$parseFunctionArgs(cls, m)
}
    #end for

    ## static methods implementation
    #for m in cls.validStaticMethods
static int ${cls.cppRefName}_${m.lua_func_name}__static(lua_State* L) {
$parseFunctionArgs(cls, m)
}
    #end for

    ## field implementation
    #for m in cls.validFields
static int ${cls.cppRefName}_${m.name}__get(lua_State* L) {
    return 0;
}

static int ${cls.cppRefName}_${m.name}__set(lua_State* L) {
    return 0;
}
    #end for

void register_${cls.cppRefName}(lua_State* L) {
    #set baseName = cls.parents[0].luaClassName if len($cls.parents) > 0 else ''
    #set finalizeName = cls.cppRefName + '__finalize' if cls.hasConstructor else 'nullptr'
    Tolua::declare_cclass(L, "${cls.luaClassName}", "${baseName}", ${finalizeName});

    #if cls.hasConstructor
    Tolua::declare_member_type(L, "constructors");
        #for name, func in cls.validConstructors.items()
    Tolua::add_member(L, "${name}", ${cls.cppRefName}__${name});
        #end for
    Tolua::declare_end(L);
    #end if
## 
    #if cls.validFields
    Tolua::declare_member_type(L, "fields");
        #for m in cls.validFields
    Tolua::add_member(L, "${m.name}.get", ${cls.cppRefName}_${m.name}__get);
    Tolua::add_member(L, "${m.name}.set", ${cls.cppRefName}_${m.name}__set);
    Tolua::declare_end(L);
        #end for
    #end if
## 
    #if cls.methods
    Tolua::declare_member_type(L, "methods");
        #for m in cls.validMethods
    Tolua::add_member(L, "${m.lua_func_name}", ${cls.cppRefName}_${m.lua_func_name});
        #end for
    Tolua::declare_end(L);
    #end if

    #if cls.static_methods
    Tolua::declare_member_type(L, "static_methods");
        #for m in cls.validStaticMethods
    Tolua::add_member(L, "${m.lua_func_name}", ${cls.cppRefName}_${m.lua_func_name}__static);
        #end for
    Tolua::declare_end(L);
    #end if

    Tolua::declare_end(L);
    auto typeName = typeid(${cls.ns_full_name}).name(); // rtti is literal storage
    Tolua::luaType[reinterpret_cast<uintptr_t>(typeName)] = "${cls.luaClassName}";
}
#end for

## registerAutoCode
void Tolua::registerAutoCode(lua_State* L)
{
    declare_ns(L, NULL);
	
#set target_ns = None
#for clsType in $classTypes
    #set cls = $parsedClasses[clsType]
    #if target_ns != cls.luaNSName
        #if target_ns != None
    declare_end(L);
        #end if
        #set target_ns = cls.luaNSName

    declare_ns(L, "${target_ns}");
    #end if
    register_${cls.cppRefName}(L);
#end for
#if target_ns != None
    declare_end(L);
#end if

    declare_end(L);
}

NS_AX_END
