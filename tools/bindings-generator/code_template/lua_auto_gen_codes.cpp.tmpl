\#pragma once

## include headers
\#include "scripting/lua-bindings/manual/Tolua.h"
#for header in $headers
    #set relative = '..'
    #for search_path in $search_paths
        #set relative = os.path.relpath(header, $search_path)
        #if not '..' in relative
            #break
        #end if
    #end for
    #if not '..' in relative
\#include "${relative.replace(os.path.sep, '/')}"
    #else
\#include "${os.path.basename(header)}"
    #end if
#end for

NS_AX_BEGIN

## struct convert logic implementation
#for structType in $structTypes
    #set structInfo = $parsedStructs[structType]
template<>
void Tolua::tolua_push_value(lua_State* L, const ${structInfo.ns_full_name} &value) {
    lua_newtable(L);
    #for field in structInfo.fields
    tolua_push_value(L, value.${field.name});
    lua_setfield(L, -2, "${field.name}");
    #end for
}

template<>
void Tolua::tolua_get_value(lua_State* L, int loc, ${structInfo.ns_full_name} &value) {
    if (!lua_istable(L, loc)) {
        return;
    }

    #for field in structInfo.fields
    lua_getfield(L, loc, "${field.name}");
    tolua_get_value(L, -1, value.${field.name});
    lua_pop(L, 1);
    #end for
}
#end for

## reister class
#for clsType in $classTypes
    #set cls = $generated_classes[clsType]

    #if cls.hasConstructor
        ## finalize
static int ${cls.cppRefName}__finalize(lua_State* L) {
    AX_ASSERT(Tolua::isusertype(L, "${cls.luaClassName}", 1));
    auto obj = (${cls.ns_full_name}*)Tolua::tousertype(L, "${cls.luaClassName}", 1);
    delete obj;
    return 0;
}
        ## constructors
        #for i in range(len(cls.constructors))
            #set func = cls.constructors[i]
            #if not func.isNotSupported
static int ${cls.cppRefName}__constructor__${i}(lua_State* L) {
    #set params = []
    #for i in range(len(func.arguments))
        #set tp = func.arguments[i]
    ${tp.cppDeclareTypeName} arg_${i};
        #silent params.append('(%s) arg_%d' % (tp.cppRealDeclareTypeName, i))
    Tolua::tolua_get_value(L, ${i}, arg_${i});
    #end for

    auto ret = new ${cls.ns_full_name}(${', '.join(params)});
    Tolua::pushusertype(L, (void*)ret , "${cls.luaClassName}");
    return 1;
}
            #end if
        #end for
    #end if

    ## methods implementation
    #for (funcName, m) in cls.methods.items()
        #if not m.isNotSupported
static int ${cls.cppRefName}_${funcName}(lua_State* L) {
    return 0;
}
        #end if
    #end for

    ## static methods implementation
    #for (funcName, m) in cls.static_methods.items()
        #if not m.isNotSupported
static int ${cls.cppRefName}_${funcName}__static(lua_State* L) {
    return 0;
}
        #end if
    #end for

    ## field implementation
    #for (m) in cls.public_fields
        #if not m.isNotSupported
static int ${cls.cppRefName}_${m.name}__get(lua_State* L) {
    return 0;
}

static int ${cls.cppRefName}_${m.name}__set(lua_State* L) {
    return 0;
}
        #end if
    #end for

void register_${cls.cppRefName}(lua_State* L) {
    #set baseName = cls.parents[0].luaClassName if len($cls.parents) > 0 else ''
    #set finalizeName = cls.cppRefName + '__finalize' if cls.hasConstructor else 'nullptr'
    Tolua::declare_cclass(L, "${cls.luaClassName}", "${baseName}", ${finalizeName});

    #if cls.hasConstructor
    Tolua::declare_member_type(L, "constructors");
        #for i in range(len(cls.constructors))
            #set func = cls.constructors[i]
            #if not func.isNotSupported
    Tolua::add_member(L, "${i}", ${cls.cppRefName}__constructor__${i});
            #end if
        #end for
    Tolua::declare_end(L);
    #end if

    #if cls.public_fields
    Tolua::declare_member_type(L, "fields");
        #for m in cls.public_fields
            #if not m.isNotSupported
    Tolua::add_member(L, "${m.name}.get", ${cls.cppRefName}_${m.name}__get);
    Tolua::add_member(L, "${m.name}.set", ${cls.cppRefName}_${m.name}__set);
            #end if
        #end for
    Tolua::declare_end(L);
    #end if

    #if cls.methods
    Tolua::declare_member_type(L, "methods");
        #for (funcName, m) in cls.methods.items()
            #if not m.isNotSupported
    Tolua::add_member(L, "${funcName}", ${cls.cppRefName}_${funcName});
            #end if
        #end for
    Tolua::declare_end(L);
    #end if

    #if cls.static_methods
    Tolua::declare_member_type(L, "static_methods");
        #for (funcName, m) in cls.static_methods.items()
            #if not m.isNotSupported
    Tolua::add_member(L, "${funcName}", ${cls.cppRefName}_${funcName}__static);
            #end if
        #end for
    Tolua::declare_end(L);
    #end if

    Tolua::declare_end(L);
    auto typeName = typeid(${cls.ns_full_name}).name(); // rtti is literal storage
    Tolua::luaType[reinterpret_cast<uintptr_t>(typeName)] = "${cls.luaClassName}";
}
#end for

## registerAutoCode
void Tolua::registerAutoCode(lua_State* L)
{
    declare_ns(L, NULL);
	
#set target_ns = None
#for clsType in $classTypes
    #set cls = $generated_classes[clsType]
    #if target_ns != cls.luaNSName
        #if target_ns != None
    declare_end(L);
        #end if
        #set target_ns = cls.luaNSName

    declare_ns(L, "${target_ns}");
    #end if
    register_${cls.cppRefName}(L);
#end for
#if target_ns != None
    declare_end(L);
#end if

    declare_end(L);
}

NS_AX_END
